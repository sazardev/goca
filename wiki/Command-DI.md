# goca di Command

The `goca di` command creates a dependency injection container that automatically connects all system layers following Clean Architecture principles.

## üìã Syntax

```bash
goca di [flags]
```

## üéØ Purpose

Creates the dependency injection system to connect all layers:

- üîß **Manual container** with explicit configuration
- ‚ö° **Google Wire** for automatic generation
- üîó **Layer connection** respecting dependencies
- üóÑÔ∏è **Database-specific configuration** per type
- üì¶ **Modular features** for different functionalities

## üö© Available Flags

| Flag         | Type     | Required  | Default Value | Description                                    |
| ------------ | -------- | --------- | ------------- | ---------------------------------------------- |
| `--features` | `string` | ‚úÖ **Yes** | -             | Project features (`crud,auth,validation,etc`)  |
| `--database` | `string` | ‚ùå No      | `postgres`    | Database type (`postgres`, `mysql`, `mongodb`) |
| `--wire`     | `bool`   | ‚ùå No      | `false`       | Use Google Wire for dependency injection       |

## üìñ Usage Examples

### Basic Manual Container
```bash
goca di --features "crud" --database postgres
```

### With Google Wire
```bash
goca di --features "crud,auth,validation" --database postgres --wire
```

### Multiple Features
```bash
goca di --features "crud,auth,validation,logging,metrics" --database mysql
```

### MongoDB with Wire
```bash
goca di --features "crud,auth" --database mongodb --wire
```

## üìÇ Generated Files

### Manual Container
```
internal/di/
‚îî‚îÄ‚îÄ container.go           # Manual dependency container
```

### With Google Wire
```
internal/di/
‚îú‚îÄ‚îÄ wire.go                # Wire definitions
‚îú‚îÄ‚îÄ wire_gen.go            # Code generated by Wire
‚îî‚îÄ‚îÄ container.go           # Wire container wrapper
```

## üîç Generated Code in Detail

### Manual Container: `internal/di/container.go`

```go
package di

import (
    "database/sql"
    "log"
    
    "github.com/gin-gonic/gin"
    _ "github.com/lib/pq"
    
    "github.com/usuario/proyecto/internal/usecase"
    "github.com/usuario/proyecto/internal/repository/postgres"
    "github.com/usuario/proyecto/internal/handler/http"
    "github.com/usuario/proyecto/pkg/config"
)

// Container contains all system dependencies
type Container struct {
    // Database
    DB *sql.DB
    
    // Repositories
    UserRepository interfaces.UserRepository
    
    // Use cases
    UserUseCase usecase.UserUseCase
    
    // Handlers
    UserHandler *http.UserHandler
    
    // Router
    Router *gin.Engine
}

// NewContainer creates and configures a new dependency container
func NewContainer() (*Container, error) {
    container := &Container{}
    
    // Configure database
    if err := container.setupDatabase(); err != nil {
        return nil, err
    }
    
    // Configure repositories
    container.setupRepositories()
    
    // Configure use cases
    container.setupUseCases()
    
    // Configure handlers
    container.setupHandlers()
    
    // Configure router
    container.setupRouter()
    
    return container, nil
}

// setupDatabase configures the database connection
func (c *Container) setupDatabase() error {
    cfg := config.Load()
    
    dbUrl := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        cfg.Database.Host,
        cfg.Database.Port,
        cfg.Database.User,
        cfg.Database.Password,
        cfg.Database.Name,
        cfg.Database.SSLMode,
    )
    
    db, err := sql.Open("postgres", dbUrl)
    if err != nil {
        return fmt.Errorf("failed to connect to database: %w", err)
    }
    
    if err := db.Ping(); err != nil {
        return fmt.Errorf("failed to ping database: %w", err)
    }
    
    c.DB = db
    log.Println("Database connected successfully")
    
    return nil
}

// setupRepositories configures all repositories
func (c *Container) setupRepositories() {
    c.UserRepository = postgres.NewUserRepository(c.DB)
    log.Println("Repositories configured")
}

// setupUseCases configures all use cases
func (c *Container) setupUseCases() {
    c.UserUseCase = usecase.NewUserService(c.UserRepository)
    log.Println("Use cases configured")
}

// setupHandlers configures all handlers
func (c *Container) setupHandlers() {
    c.UserHandler = http.NewUserHandler(c.UserUseCase)
    log.Println("Handlers configured")
}

// setupRouter configures the router with all routes
func (c *Container) setupRouter() {
    router := gin.Default()
    
    // Global middleware
    router.Use(gin.Logger())
    router.Use(gin.Recovery())
    router.Use(corsMiddleware())
    
    // Health check
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
    
    // API v1
    v1 := router.Group("/api/v1")
    {
        // User routes
        http.RegisterUserRoutes(v1, c.UserUseCase)
    }
    
    c.Router = router
    log.Println("Router configured with all routes")
}

// Close closes all connections
func (c *Container) Close() error {
    if c.DB != nil {
        if err := c.DB.Close(); err != nil {
            return fmt.Errorf("failed to close database: %w", err)
        }
    }
    
    return nil
}

// corsMiddleware configures CORS
func corsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

### Google Wire: `internal/di/wire.go`

```go
//go:build wireinject
// +build wireinject

package di

import (
    "database/sql"
    
    "github.com/google/wire"
    "github.com/gin-gonic/gin"
    
    "github.com/usuario/proyecto/internal/usecase"
    "github.com/usuario/proyecto/internal/repository/postgres"
    "github.com/usuario/proyecto/internal/handler/http"
    "github.com/usuario/proyecto/pkg/config"
)

// WireContainer contains dependencies injected by Wire
type WireContainer struct {
    DB          *sql.DB
    UserHandler *http.UserHandler
    Router      *gin.Engine
}

// DatabaseSet provider set for database
var DatabaseSet = wire.NewSet(
    provideDatabaseConnection,
)

// RepositorySet provider set for repositories
var RepositorySet = wire.NewSet(
    postgres.NewUserRepository,
    wire.Bind(new(interfaces.UserRepository), new(*postgres.UserRepository)),
)

// UseCaseSet provider set for use cases
var UseCaseSet = wire.NewSet(
    usecase.NewUserService,
    wire.Bind(new(usecase.UserUseCase), new(*usecase.UserService)),
)

// HandlerSet provider set for handlers
var HandlerSet = wire.NewSet(
    http.NewUserHandler,
)

// RouterSet provider set for router
var RouterSet = wire.NewSet(
    provideRouter,
)

// InitializeContainer initializes the container with Wire
func InitializeContainer() (*WireContainer, error) {
    wire.Build(
        DatabaseSet,
        RepositorySet,
        UseCaseSet,
        HandlerSet,
        RouterSet,
        wire.Struct(new(WireContainer), "*"),
    )
    return &WireContainer{}, nil
}

// provideDatabaseConnection provides the database connection
func provideDatabaseConnection() (*sql.DB, error) {
    cfg := config.Load()
    
    dbUrl := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        cfg.Database.Host,
        cfg.Database.Port,
        cfg.Database.User,
        cfg.Database.Password,
        cfg.Database.Name,
        cfg.Database.SSLMode,
    )
    
    db, err := sql.Open("postgres", dbUrl)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }
    
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    return db, nil
}

// provideRouter provides the configured router
func provideRouter(userHandler *http.UserHandler) *gin.Engine {
    router := gin.Default()
    
    // Global middleware
    router.Use(gin.Logger())
    router.Use(gin.Recovery())
    
    // Health check
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
    
    // API v1
    v1 := router.Group("/api/v1")
    {
        // User routes
        users := v1.Group("/users")
        {
            users.POST("", userHandler.Create)
            users.GET("", userHandler.List)
            users.GET("/:id", userHandler.GetByID)
            users.PUT("/:id", userHandler.Update)
            users.DELETE("/:id", userHandler.Delete)
        }
    }
    
    return router
}
```

### Wrapper Wire: `internal/di/wire_container.go`

```go
package di

import (
    "database/sql"
    "log"
    
    "github.com/gin-gonic/gin"
)

// Container wrapper for the Wire container
type Container struct {
    wireContainer *WireContainer
}

// NewContainer creates a new container using Wire
func NewContainer() (*Container, error) {
    wireContainer, err := InitializeContainer()
    if err != nil {
        return nil, err
    }
    
    log.Println("Wire container initialized successfully")
    
    return &Container{
        wireContainer: wireContainer,
    }, nil
}

// GetDB returns the database connection
func (c *Container) GetDB() *sql.DB {
    return c.wireContainer.DB
}

// GetRouter returns the configured router
func (c *Container) GetRouter() *gin.Engine {
    return c.wireContainer.Router
}

// Close closes all connections
func (c *Container) Close() error {
    if c.wireContainer.DB != nil {
        if err := c.wireContainer.DB.Close(); err != nil {
            return err
        }
    }
    
    return nil
}
```

## üíæ Database-Specific Configuration

### PostgreSQL
```go
func setupPostgresDatabase() (*sql.DB, error) {
    cfg := config.Load()
    
    dbUrl := fmt.Sprintf(
        "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        cfg.Database.Host,
        cfg.Database.Port,
        cfg.Database.User,
        cfg.Database.Password,
        cfg.Database.Name,
        cfg.Database.SSLMode,
    )
    
    db, err := sql.Open("postgres", dbUrl)
    if err != nil {
        return nil, err
    }
    
    // PostgreSQL-specific configuration
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(25)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    return db, nil
}
```

### MySQL
```go
func setupMySQLDatabase() (*sql.DB, error) {
    cfg := config.Load()
    
    dsn := fmt.Sprintf(
        "%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        cfg.Database.User,
        cfg.Database.Password,
        cfg.Database.Host,
        cfg.Database.Port,
        cfg.Database.Name,
    )
    
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    
    // MySQL-specific configuration
    db.SetMaxOpenConns(20)
    db.SetMaxIdleConns(10)
    db.SetConnMaxLifetime(3 * time.Minute)
    
    return db, nil
}
```

### MongoDB
```go
func setupMongoDatabase() (*mongo.Database, error) {
    cfg := config.Load()
    
    clientOptions := options.Client().ApplyURI(cfg.Database.URI)
    client, err := mongo.Connect(context.Background(), clientOptions)
    if err != nil {
        return nil, err
    }
    
    // Verify connection
    if err := client.Ping(context.Background(), nil); err != nil {
        return nil, err
    }
    
    db := client.Database(cfg.Database.Name)
    return db, nil
}
```

## üéØ Configurable Features

### CRUD Feature
```go
// With --features "crud"
func setupCRUDFeatures(container *Container) {
    // Basic CRUD repositories
    container.UserRepository = postgres.NewUserRepository(container.DB)
    
    // CRUD use cases
    container.UserUseCase = usecase.NewUserService(container.UserRepository)
    
    // CRUD handlers
    container.UserHandler = http.NewUserHandler(container.UserUseCase)
}
```

### Auth Feature
```go
// With --features "crud,auth"
func setupAuthFeatures(container *Container) {
    // JWT Service
    container.JWTService = auth.NewJWTService(
        os.Getenv("JWT_SECRET"),
        "goca-app",
    )
    
    // Auth Middleware
    container.AuthMiddleware = auth.NewAuthMiddleware(container.JWTService)
    
    // Auth Use Case
    container.AuthUseCase = auth.NewAuthService(
        container.UserRepository,
        container.JWTService,
    )
    
    // Auth Handler
    container.AuthHandler = http.NewAuthHandler(container.AuthUseCase)
}
```

### Validation Feature
```go
// With --features "crud,validation"
func setupValidationFeatures(container *Container) {
    // Validator
    container.Validator = validator.New()
    
    // Validation Middleware
    container.ValidationMiddleware = middleware.NewValidationMiddleware(container.Validator)
    
    // Enhanced Use Cases with validation
    container.UserUseCase = usecase.NewUserServiceWithValidation(
        container.UserRepository,
        container.Validator,
    )
}
```

### Logging Feature
```go
// With --features "crud,logging"
func setupLoggingFeatures(container *Container) {
    // Logger
    container.Logger = logger.New()
    
    // Logging Middleware
    container.LoggingMiddleware = middleware.NewLoggingMiddleware(container.Logger)
    
    // Enhanced Use Cases with logging
    container.UserUseCase = usecase.NewUserServiceWithLogging(
        container.UserRepository,
        container.Logger,
    )
}
```

## üîß Container Usage

### In main.go
```go
package main

import (
    "log"
    "context"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/usuario/proyecto/internal/di"
)

func main() {
    // Initialize container
    container, err := di.NewContainer()
    if err != nil {
        log.Fatal("Failed to initialize container:", err)
    }
    defer container.Close()
    
    // Configure server
    server := &http.Server{
        Addr:    ":8080",
        Handler: container.GetRouter(),
    }
    
    // Start server in goroutine
    go func() {
        log.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal("Failed to start server:", err)
        }
    }()
    
    // Wait for termination signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // Graceful shutdown
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

### In Tests
```go
func setupTestContainer(t *testing.T) *di.Container {
    // Configure test database
    testDB := setupTestDB(t)
    
    container := &di.Container{
        DB: testDB,
    }
    
    // Configure dependencies for tests
    container.UserRepository = postgres.NewUserRepository(testDB)
    container.UserUseCase = usecase.NewUserService(container.UserRepository)
    container.UserHandler = http.NewUserHandler(container.UserUseCase)
    
    return container
}

func TestUserCreation(t *testing.T) {
    container := setupTestContainer(t)
    defer container.Close()
    
    // Use the container in tests
    // ...
}
```

## üèóÔ∏è Wire Commands

### Generate Wire code
```bash
# Install Wire
go install github.com/google/wire/cmd/wire@latest

# Generate code
cd internal/di
wire
```

### Verify dependencies
```bash
# Verify that Wire can resolve all dependencies
wire check
```

## ‚ö†Ô∏è Important Considerations

### ‚úÖ Best Practices
- **Clear interfaces**: Define interfaces for all dependencies
- **Singleton pattern**: Use a single container instance
- **Graceful shutdown**: Close resources appropriately
- **Centralized configuration**: Centralize all configuration

### ‚ùå Common Errors
- **Circular dependencies**: Avoid circular dependencies
- **Memory leaks**: Not closing resources properly
- **Hard-coded values**: Use configuration for all values
- **Missing error handling**: Handle initialization errors

### üîÑ Recommended Dependencies

To use Wire, add to `go.mod`:
```go
require (
    github.com/google/wire v0.5.0
)
```

For manual container:
```go
require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9          // PostgreSQL
    github.com/go-sql-driver/mysql v1.7.1  // MySQL
    go.mongodb.org/mongo-driver v1.12.1     // MongoDB
)
```

---

**‚Üê [goca handler Command](Command-Handler) | [goca interfaces Command](Command-Interfaces) ‚Üí**
