# Goca - Go Clean Architecture Code Generator

[![Go Version](https://img.shields.io/badge/Go-1.24.5+-00ADD8?style=flat&logo=go)](https://golang.org/)
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Build Status](https://img.shields.io/badge/Build-Passing-brightgreen.svg)](https://github.com/sazardev/goca)

Goca es un potente generador de c√≥digo CLI para Go que te ayuda a crear proyectos con Clean Architecture siguiendo las mejores pr√°cticas. Genera c√≥digo limpio y bien estructurado por capas, permiti√©ndote enfocarte en la l√≥gica de negocio en lugar de tareas repetitivas de configuraci√≥n.

## üèóÔ∏è Filosof√≠a de Clean Architecture

Cada feature generado por Goca sigue estrictamente los principios de Clean Architecture:

- **üü° Capa de Dominio**: Entidades puras sin dependencias externas
- **üî¥ Capa de Casos de Uso**: L√≥gica de aplicaci√≥n con DTOs y validaciones de negocio
- **üü¢ Capa de Adaptadores**: Interfaces HTTP, gRPC, CLI que adaptan entrada/salida
- **üîµ Capa de Infraestructura**: Repositorios que implementan persistencia de datos

### ‚úÖ Garant√≠as de Buenas Pr√°cticas

- Dependencias orientadas hacia el n√∫cleo del sistema
- Interfaces y contratos claros entre capas
- L√≥gica de negocio encapsulada en capas internas
- Responsabilidades claramente segregadas
- Inyecci√≥n de dependencias para m√°xima testabilidad

### üö´ Prevenci√≥n de Malas Pr√°cticas

- Evita mezclar l√≥gica t√©cnica con l√≥gica de negocio
- Impide dependencias directas de entidades hacia infraestructura
- Genera paquetes bien estructurados y cohesivos

## üß† Principios y Anti-Patrones Implementados

### ‚úÖ Patrones Aplicados
- **Repository Pattern**: Abstracci√≥n de persistencia de datos
- **Dependency Injection**: Inversi√≥n de control entre capas
- **CQRS**: Separaci√≥n de comandos y consultas en casos de uso
- **Interface Segregation**: Contratos espec√≠ficos por responsabilidad

### üö´ Anti-Patrones Prevenidos
- **Fat Controller**: L√≥gica de negocio en handlers
- **God Object**: Entidades con demasiadas responsabilidades
- **Anemic Domain Model**: Entidades sin comportamiento
- **Direct Database Access**: Dependencias directas a infraestructura

## üîç Validaci√≥n de Clean Architecture

Goca garantiza que cada archivo generado cumple con:

- **Regla de Dependencias**: C√≥digo interno nunca depende de c√≥digo externo
- **Separaci√≥n de Responsabilidades**: Cada capa tiene una √∫nica raz√≥n para cambiar
- **Principio de Inversi√≥n**: Detalles dependen de abstracciones
- **Interfaces Limpias**: Contratos claros entre capas

## üöÄ Features Principales

- **Generaci√≥n por Capas**: Cada comando genera c√≥digo espec√≠fico para una capa de Clean Architecture
- **Feature Completo**: Un comando genera toda la estructura necesaria para un feature
- **Entidades de Dominio**: Genera entidades puras con validaciones de negocio
- **Casos de Uso**: Crea servicios de aplicaci√≥n con DTOs bien definidos
- **Repositorios**: Genera interfaces y implementaciones siguiendo Repository Pattern
- **Handlers Multi-Protocolo**: Soporta HTTP, gRPC, CLI manteniendo separaci√≥n de capas
- **Inyecci√≥n de Dependencias**: Estructura preparada para DI desde el inicio

## üì¶ Instalaci√≥n

### Usando Go Install (Recomendado)
```bash
go install github.com/sazardev/goca@latest
```

### Descarga de Binarios
Descarga el binario directamente desde [GitHub Releases](https://github.com/sazardev/goca/releases):

**Windows:**
```bash
# Descargar goca-windows-amd64.exe desde releases
# Renombrar a goca.exe y agregar al PATH
```

**Linux:**
```bash
# Descargar y hacer ejecutable
wget https://github.com/sazardev/goca/releases/latest/download/goca-linux-amd64
chmod +x goca-linux-amd64
sudo mv goca-linux-amd64 /usr/local/bin/goca
```

**macOS:**
```bash
# Intel Macs
wget https://github.com/sazardev/goca/releases/latest/download/goca-darwin-amd64
chmod +x goca-darwin-amd64
sudo mv goca-darwin-amd64 /usr/local/bin/goca

# Apple Silicon Macs  
wget https://github.com/sazardev/goca/releases/latest/download/goca-darwin-arm64
chmod +x goca-darwin-arm64
sudo mv goca-darwin-arm64 /usr/local/bin/goca
```

### Desde C√≥digo Fuente
```bash
git clone https://github.com/sazardev/goca.git
cd goca
go build -o goca
```

## üõ†Ô∏è Inicio R√°pido

### Inicializar Proyecto Clean Architecture
```bash
# Crear nuevo proyecto con estructura Clean Architecture
goca init myproject --module github.com/sazardev/myproject

# Navegar al proyecto
cd myproject

# Instalar dependencias
go mod tidy
```

### Generar Feature Completo
```bash
# Generar feature completo con todas las capas
goca feature Employee --fields "name:string,email:string,role:string" --database postgres
```

## üîÑ Flujo de Trabajo Recomendado

1. **Generar Dominio**: `goca entity Employee --fields "name:string,email:string"`
2. **Generar Casos de Uso**: `goca usecase EmployeeService --entity Employee`
3. **Generar Repositorio**: `goca repository Employee --database postgres`
4. **Generar Handlers**: `goca handler Employee --type http`
5. **Generar DI**: `goca di --features Employee`

## üìö Comandos por Capas

### üü° Capa de Dominio

#### `goca entity`
Genera entidades de dominio puras siguiendo DDD.
```bash
goca entity <name> [flags]

# Flags:
--fields string     Campos de la entidad "name:type,email:string"
--validation       Agregar validaciones de dominio
--business-rules   Incluir m√©todos de reglas de negocio
```

**Ejemplo:**
```bash
goca entity Product --fields "name:string,price:float64,category:string" --validation --business-rules
```

**C√≥digo Generado:**
```go
// domain/product.go
package domain

type Product struct {
    ID       int
    Name     string
    Price    float64
    Category string
}

func (p *Product) Validate() error {
    if p.Name == "" || p.Price <= 0 {
        return ErrInvalidProductData
    }
    return nil
}

func (p *Product) IsExpensive() bool {
    return p.Price > 1000.0
}
```

### üî¥ Capa de Casos de Uso

#### `goca usecase`
Genera servicios de aplicaci√≥n con DTOs y l√≥gica de negocio.
```bash
goca usecase <name> [flags]

# Flags:
--entity string    Entidad asociada
--operations string Operaciones CRUD (create,read,update,delete,list)
--dto-validation   DTOs con validaciones espec√≠ficas
```

**Ejemplo:**
```bash
goca usecase ProductService --entity Product --operations "create,read,update,delete,list" --dto-validation
```

**C√≥digo Generado:**
```go
// usecase/product_service.go
package usecase

import "myproject/domain"

type CreateProductInput struct {
    Name     string `validate:"required,min=3"`
    Price    float64 `validate:"required,gt=0"`
    Category string `validate:"required"`
}

type CreateProductOutput struct {
    Product domain.Product
    Message string
}

type ProductUseCase interface {
    CreateProduct(input CreateProductInput) (CreateProductOutput, error)
    GetProduct(id int) (domain.Product, error)
    UpdateProduct(id int, input UpdateProductInput) error
    DeleteProduct(id int) error
    ListProducts() ([]domain.Product, error)
}
```

### üü¢ Capa de Adaptadores (Handlers)

#### `goca handler`
Genera adaptadores de entrega para diferentes protocolos.
```bash
goca handler <entity> [flags]

# Flags:
--type string     Tipo de handler (http, grpc, cli, worker, soap)
--middleware      Incluir setup de middleware
--validation      Validaci√≥n de entrada en handler
```

**Ejemplo HTTP:**
```bash
goca handler Product --type http --middleware --validation
```

**C√≥digo Generado:**
```go
// handler/http/product_handler.go
package http

import (
    "encoding/json"
    "net/http"
    "myproject/usecase"
)

type ProductHandler struct {
    usecase usecase.ProductUseCase
}

func NewProductHandler(uc usecase.ProductUseCase) *ProductHandler {
    return &ProductHandler{usecase: uc}
}

func (h *ProductHandler) CreateProduct(w http.ResponseWriter, r *http.Request) {
    var input usecase.CreateProductInput
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    output, err := h.usecase.CreateProduct(input)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(output)
}
```

### üîµ Capa de Infraestructura

#### `goca repository`
Genera repositorios con interfaces e implementaciones.
```bash
goca repository <entity> [flags]

# Flags:
--database string  Tipo de base de datos (postgres, mysql, mongodb)
--interface-only   Solo generar interfaces
--implementation   Solo generar implementaci√≥n
```

**Ejemplo:**
```bash
goca repository Product --database postgres
```

**C√≥digo Generado:**
```go
// repository/interfaces/product_repository.go
package interfaces

import "myproject/domain"

type ProductRepository interface {
    Save(product *domain.Product) error
    FindByID(id int) (*domain.Product, error)
    FindAll() ([]domain.Product, error)
    Update(product *domain.Product) error
    Delete(id int) error
}

// repository/postgres/product_repository.go
package postgres

import (
    "database/sql"
    "myproject/domain"
    "myproject/repository/interfaces"
)

type postgresProductRepository struct {
    db *sql.DB
}

func NewPostgresProductRepository(db *sql.DB) interfaces.ProductRepository {
    return &postgresProductRepository{db: db}
}

func (r *postgresProductRepository) Save(product *domain.Product) error {
    query := `INSERT INTO products (name, price, category) VALUES ($1, $2, $3) RETURNING id`
    err := r.db.QueryRow(query, product.Name, product.Price, product.Category).Scan(&product.ID)
    return err
}
```

### Comandos Auxiliares

#### `goca messages`
Genera archivos de mensajes y constantes.
```bash
goca messages <entity> [flags]

# Flags:
--errors       Generar mensajes de error
--responses    Generar mensajes de respuesta
--constants    Generar constantes del feature
```

## üìÅ Estructura Completa por Feature (Ejemplo: Employee)

```
employee/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ employee.go          # Entidad pura
‚îÇ   ‚îú‚îÄ‚îÄ errors.go           # Errores de dominio
‚îÇ   ‚îî‚îÄ‚îÄ validations.go      # Validaciones de negocio
‚îú‚îÄ‚îÄ usecase/
‚îÇ   ‚îú‚îÄ‚îÄ dto.go              # DTOs de entrada/salida
‚îÇ   ‚îú‚îÄ‚îÄ employee_usecase.go # Interfaz de casos de uso
‚îÇ   ‚îú‚îÄ‚îÄ employee_service.go # Implementaci√≥n de casos de uso
‚îÇ   ‚îî‚îÄ‚îÄ interfaces.go       # Contratos hacia otras capas
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îú‚îÄ‚îÄ interfaces.go       # Contratos de persistencia
‚îÇ   ‚îú‚îÄ‚îÄ postgres_employee_repo.go  # Implementaci√≥n PostgreSQL
‚îÇ   ‚îî‚îÄ‚îÄ memory_employee_repo.go    # Implementaci√≥n en memoria
‚îú‚îÄ‚îÄ handler/
‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto.go          # DTOs espec√≠ficos de HTTP
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handler.go      # Controlador HTTP
‚îÇ   ‚îú‚îÄ‚îÄ grpc/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ employee.proto  # Definici√≥n gRPC
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.go       # Servidor gRPC
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commands.go     # Comandos CLI
‚îÇ   ‚îú‚îÄ‚îÄ worker/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ worker.go       # Workers/Jobs
‚îÇ   ‚îî‚îÄ‚îÄ soap/
‚îÇ       ‚îî‚îÄ‚îÄ soap_client.go  # Cliente SOAP
‚îú‚îÄ‚îÄ messages/
‚îÇ   ‚îú‚îÄ‚îÄ errors.go           # Mensajes de error
‚îÇ   ‚îî‚îÄ‚îÄ responses.go        # Mensajes de respuesta
‚îú‚îÄ‚îÄ constants/
‚îÇ   ‚îî‚îÄ‚îÄ constants.go        # Constantes del feature
‚îî‚îÄ‚îÄ main.go                 # Punto de entrada
```

## üìã Buenas vs Malas Pr√°cticas por Capa

### üü° Dominio - Qu√© S√ç y NO hacer

#### ‚úÖ Buenas Pr√°cticas:
```go
// ‚úÖ Entidad pura con validaciones de negocio
type Employee struct {
    ID    int
    Name  string
    Email string
    Role  string
}

func (e *Employee) Validate() error {
    if e.Name == "" || e.Email == "" {
        return ErrInvalidEmployeeData
    }
    return nil
}

func (e *Employee) IsManager() bool {
    return e.Role == "manager"
}
```

#### ‚ùå Malas Pr√°cticas:
```go
// ‚ùå NUNCA: Dependencias de infraestructura en dominio
type Employee struct {
    ID int
    DB *sql.DB // ‚ùå Dependencia externa
}

// ‚ùå NUNCA: L√≥gica t√©cnica en dominio
func (e *Employee) SaveToDatabase() error // ‚ùå Responsabilidad incorrecta

// ‚ùå NUNCA: Importar paquetes de capas externas
import "myproject/handler/http" // ‚ùå Violaci√≥n de dependencias
```

### üî¥ Casos de Uso - Qu√© S√ç y NO hacer

#### ‚úÖ Buenas Pr√°cticas:
```go
// ‚úÖ DTOs bien definidos
type CreateEmployeeInput struct {
    Name  string `validate:"required"`
    Email string `validate:"required,email"`
}

// ‚úÖ Interfaces hacia otras capas
type EmployeeRepository interface {
    Save(*domain.Employee) error
}

// ‚úÖ L√≥gica de aplicaci√≥n pura
func (s *EmployeeService) CreateEmployee(input CreateEmployeeInput) error {
    emp := domain.Employee{Name: input.Name, Email: input.Email}
    if err := emp.Validate(); err != nil {
        return err
    }
    return s.repo.Save(&emp)
}
```

#### ‚ùå Malas Pr√°cticas:
```go
// ‚ùå NUNCA: Dependencias de infraestructura directas
func (s *EmployeeService) CreateEmployee(db *sql.DB) error // ‚ùå Acoplamiento

// ‚ùå NUNCA: L√≥gica de presentaci√≥n
func (s *EmployeeService) CreateEmployeeJSON() string // ‚ùå Responsabilidad incorrecta

// ‚ùå NUNCA: Detalles de implementaci√≥n
func (s *EmployeeService) CreateEmployeeWithPostgres() error // ‚ùå Especificidad t√©cnica
```

### üü¢ Adaptadores - Qu√© S√ç y NO hacer

#### ‚úÖ Buenas Pr√°cticas:
```go
// ‚úÖ Solo transformaci√≥n de datos
func (h *EmployeeHandler) CreateEmployee(w http.ResponseWriter, r *http.Request) {
    var httpInput HTTPCreateEmployeeInput
    json.NewDecoder(r.Body).Decode(&httpInput)
    
    usecaseInput := usecase.CreateEmployeeInput{
        Name:  httpInput.Name,
        Email: httpInput.Email,
    }
    
    err := h.usecase.CreateEmployee(usecaseInput)
    // Manejar respuesta HTTP
}
```

#### ‚ùå Malas Pr√°cticas:
```go
// ‚ùå NUNCA: L√≥gica de negocio en handlers
func (h *EmployeeHandler) CreateEmployee(w http.ResponseWriter, r *http.Request) {
    // ‚ùå Validaciones de negocio aqu√≠
    if employee.Salary < 0 {
        return errors.New("invalid salary")
    }
}

// ‚ùå NUNCA: Acceso directo a repositorios
func (h *EmployeeHandler) CreateEmployee(repo EmployeeRepository) // ‚ùå Saltarse casos de uso
```

### üîµ Infraestructura - Qu√© S√ç y NO hacer

#### ‚úÖ Buenas Pr√°cticas:
```go
// ‚úÖ Implementaci√≥n espec√≠fica de persistencia
func (r *PostgresEmployeeRepo) Save(emp *domain.Employee) error {
    query := "INSERT INTO employees (name, email) VALUES ($1, $2)"
    _, err := r.db.Exec(query, emp.Name, emp.Email)
    return err
}

// ‚úÖ Implementar interfaces del dominio
func NewPostgresEmployeeRepo(db *sql.DB) domain.EmployeeRepository {
    return &PostgresEmployeeRepo{db: db}
}
```

#### ‚ùå Malas Pr√°cticas:
```go
// ‚ùå NUNCA: Exponer tipos espec√≠ficos de DB
func (r *PostgresEmployeeRepo) GetDB() *sql.DB // ‚ùå Detalle t√©cnico expuesto

// ‚ùå NUNCA: L√≥gica de negocio en repositorios
func (r *PostgresEmployeeRepo) ValidateAndSave(emp *domain.Employee) error {
    if emp.Salary < 0 { // ‚ùå Validaci√≥n de negocio aqu√≠
        return errors.New("invalid salary")
    }
}
```

## üîß Comandos Avanzados

### Generar Feature Completo
```bash
# Genera todas las capas para un feature
goca feature <name> --fields "field:type,..." --database postgres --handlers "http,grpc,cli"
```

### Generar Solo Interfaces
```bash
# √ötil para TDD - generar contratos primero
goca interfaces Product --usecase --repository
```

### Generar Inyecci√≥n de Dependencias
```bash
# Genera contenedor DI para wiring autom√°tico
goca di --features "Product,User,Order"
```

## üéØ Ventajas de Cada Capa

### üü° Dominio
- **Entidades puras** sin dependencias externas
- **Reglas de negocio** centralizadas y testables
- **Validaciones** espec√≠ficas del dominio

### üî¥ Casos de Uso
- **DTOs espec√≠ficos** para cada operaci√≥n
- **L√≥gica de aplicaci√≥n** bien definida
- **Interfaces claras** hacia otras capas

### üü¢ Adaptadores
- **Separaci√≥n total** entre protocolos de entrada
- **Validaciones de entrada** espec√≠ficas por protocolo
- **Transformaci√≥n** de DTOs externos a internos

### üîµ Infraestructura
- **Implementaciones intercambiables** de persistencia
- **Aislamiento** de detalles t√©cnicos
- **Configuraci√≥n** centralizada de recursos externos

## üîÑ Flujo de Dependencias

```
Handler ‚Üí UseCase ‚Üí Repository ‚Üí Database
   ‚Üì         ‚Üì         ‚Üì
 DTO ‚Üê‚Üí Business ‚Üê‚Üí Domain Entity
```

**Regla de Oro**: Las dependencias siempre apuntan hacia adentro, hacia el dominio.

## ü§ù Contribuir

1. Fork el repositorio
2. Crea tu rama de feature (`git checkout -b feature/clean-arch-enhancement`)
3. Commit tus cambios (`git commit -m 'Add enhanced clean architecture layer'`)
4. Push a la rama (`git push origin feature/clean-arch-enhancement`)
5. Abre un Pull Request

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT - ver el archivo [LICENSE](LICENSE) para detalles.

## üÜò Soporte

- üìß Email: support@goca.dev
- üêõ Issues: [GitHub Issues](https://github.com/sazardev/goca/issues)
- üìñ Documentaci√≥n: [Documentaci√≥n Completa](https://docs.goca.dev)

---

Hecho