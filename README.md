# Goca - Go Clean Architecture Code Generator

[![Go Version](https://img.shields.io/badge/Go-1.24.5+-00ADD8?style=flat&logo=go)](https://golang.org/)
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Build Status](https://img.shields.io/badge/Build-Passing-brightgreen.svg)](https://github.com/sazardev/goca)
[![Production Ready](https://img.shields.io/badge/Status-Production%20Ready-brightgreen.svg)](docs/BUG_FIXES_REPORT.md)
[![GitHub Release](https://img.shields.io/github/v/release/sazardev/goca?style=flat&logo=github)](https://github.com/sazardev/goca/releases)
[![Docs](https://img.shields.io/badge/Docs-VitePress-blueviolet.svg)](https://sazardev.github.io/goca)

Goca is a powerful CLI code generator for Go that helps you create Clean Architecture projects following best practices. It generates clean, well-structured layered code, allowing you to focus on business logic instead of repetitive configuration tasks.

## Documentation

- **[Complete Documentation Website](https://sazardev.github.io/goca)** - Beautiful, searchable VitePress docs
- **[Quick Start Guide](https://sazardev.github.io/goca/getting-started)** - Get started in 5 minutes
- **[Complete Tutorial](https://sazardev.github.io/goca/tutorials/complete-tutorial)** - Build a real application
- **[Clean Architecture Guide](https://sazardev.github.io/goca/guide/clean-architecture)** - Learn the principles
- **[Commands Reference](https://sazardev.github.io/goca/commands/)** - All commands documented

## Clean Architecture Philosophy

Every feature generated by Goca strictly follows Clean Architecture principles:

- **ğŸŸ¡ Domain Layer**: Pure entities without external dependencies
- **ğŸ”´ Use Case Layer**: Application logic with DTOs and business validations
- **ğŸŸ¢ Adapter Layer**: HTTP, gRPC, CLI interfaces that adapt input/output
- **ğŸ”µ Infrastructure Layer**: Repositories that implement data persistence

### âœ… Best Practices Guaranteed

- Dependencies oriented towards the system core
- Clear interfaces and contracts between layers
- Business logic encapsulated in internal layers
- Clearly segregated responsibilities
- Dependency injection for maximum testability

### ğŸš« Bad Practices Prevention

- Prevents mixing technical logic with business logic
- Prevents direct dependencies from entities to infrastructure
- Generates well-structured and cohesive packages

## ğŸ§  Implemented Principles and Anti-Patterns

### âœ… Applied Patterns
- **Repository Pattern**: Data persistence abstraction
- **Dependency Injection**: Inversion of control between layers
- **CQRS**: Separation of commands and queries in use cases
- **Interface Segregation**: Specific contracts per responsibility

### ğŸš« Prevented Anti-Patterns
- **Fat Controller**: Business logic in handlers
- **God Object**: Entities with too many responsibilities
- **Anemic Domain Model**: Entities without behavior
- **Direct Database Access**: Direct dependencies to infrastructure

## ğŸ” Clean Architecture Validation

Goca guarantees that every generated file complies with:

- **Dependency Rule**: Internal code never depends on external code
- **Separation of Concerns**: Each layer has a single reason to change
- **Inversion Principle**: Details depend on abstractions
- **Clean Interfaces**: Clear contracts between layers

## ğŸš€ Main Features

- **Layer-based Generation**: Each command generates code specific to a Clean Architecture layer
- **Complete Feature**: One command generates all necessary structure for a feature
- **Domain Entities**: Generates pure entities with business validations
- **Use Cases**: Creates application services with well-defined DTOs
- **Repositories**: Generates interfaces and implementations following Repository Pattern
- **Multi-Protocol Handlers**: Supports HTTP, gRPC, CLI maintaining layer separation
- **Dependency Injection**: Structure prepared for DI from the start
- **Integration Testing**: Auto-generate comprehensive integration tests with fixtures and helpers (v1.14.0+)

## ğŸ“¦ Installation

### Recommended: Binary from GitHub Releases
Download the latest stable version with proper version info from [GitHub Releases](https://github.com/sazardev/goca/releases):

**Linux:**
```bash
# Download latest release
wget https://github.com/sazardev/goca/releases/latest/download/goca-linux-amd64
chmod +x goca-linux-amd64
sudo mv goca-linux-amd64 /usr/local/bin/goca

# Verify installation
goca version
```

**macOS:**
```bash
# Intel Macs
wget https://github.com/sazardev/goca/releases/latest/download/goca-darwin-amd64
chmod +x goca-darwin-amd64
sudo mv goca-darwin-amd64 /usr/local/bin/goca

# Apple Silicon Macs  
wget https://github.com/sazardev/goca/releases/latest/download/goca-darwin-arm64
chmod +x goca-darwin-arm64
sudo mv goca-darwin-arm64 /usr/local/bin/goca

# Verify installation
goca version
```

**Windows:**
```powershell
# Download goca-windows-amd64.exe from GitHub Releases
# Rename to goca.exe and add to PATH

# Verify installation
goca version
```

### Alternative: Using Go Install
```bash
# Install from source (version info will show "dev")
go install github.com/sazardev/goca@latest

# Note: go install builds from source without version injection
# For proper version info, use binary releases above
```

### For Development
```bash
# Clone and build with proper version injection
git clone https://github.com/sazardev/goca.git
cd goca
make build

# The binary will be created in current directory
# Move to PATH if needed:
sudo mv goca /usr/local/bin/goca
```

## ğŸ› ï¸ Quick Start

### Initialize Clean Architecture Project
```bash
# Create new project with Clean Architecture structure
goca init myproject --module github.com/sazardev/myproject

# Navigate to project
cd myproject

# Install dependencies
go mod tidy
```

### Generate Complete Feature (NEW - Auto-Integrated)
```bash
# Generate complete feature with all layers + automatic integration
goca feature Employee --fields "name:string,email:string,role:string"

# Ready to go! The feature is completely functional
go run main.go
```

### Integrate Existing Features (NEW)
```bash
# For projects with features not integrated
goca integrate --all

# Automatically detects all features and connects them
```

## âš¡ NEW in v1.11.0: Safety & Dependency Features

Goca now includes production-ready safety features to prevent common mistakes:

### ğŸ›¡ï¸ Safety Features

- **ğŸ” Dry-Run Mode** (`--dry-run`): Preview all changes before creating files
- **âš ï¸ File Conflict Detection**: Automatically detects existing files to prevent accidental overwrites
- **ğŸ‘¤ Name Conflict Detection**: Scans project for duplicate entity/feature names
- **ğŸ“¦ Automatic Backup** (`--backup`): Backup files before overwriting
- **ğŸ’ª Force Overwrite** (`--force`): Override protection when needed
- **ğŸ“š Version Compatibility**: Verifies Go version compatibility (1.21+)

### ğŸ“¦ Dependency Management

- **ğŸ¤– Automatic go.mod Updates**: Auto-updates dependencies when generating features
- **ï¿½ Smart Suggestions**: Recommends optional dependencies based on feature type
- **âœ… Version Verification**: Validates dependency versions and integrity

### Example Usage

```bash
# Preview changes before generating
goca feature User --fields "name:string,email:string" --dry-run

# Safe generation with conflict detection
goca feature User --fields "name:string,email:string"

# Update existing feature with backup
goca feature User --fields "name:string,email:string,role:string" --force --backup
```

**[ğŸ“– Complete Safety Features Documentation](docs/features/safety-and-dependencies.md)**

## ï¿½ğŸ“‹ Main Commands

| Command              | Purpose                                 | Automatic Integration       |
| -------------------- | --------------------------------------- | --------------------------- |
| **`goca init`**      | Initialize Clean Architecture project   | âœ… Complete structure + Git  |
| **`goca feature`**   | Generate complete feature (all layers)  | âœ… Auto-DI + Routes + Safety |
| **`goca integrate`** | **NEW**: Integrate existing features    | âœ… Repair/update integration |
| `goca entity`        | Generate domain entities only           | âŒ Manual                    |
| `goca usecase`       | Generate use cases only                 | âŒ Manual                    |
| `goca repository`    | Generate repositories only              | âŒ Manual                    |
| `goca handler`       | Generate handlers only                  | âŒ Manual                    |
| `goca di`            | Generate dependency injection container | âŒ Manual                    |

## ğŸ”„ Recommended Workflow

1. **Generate Domain**: `goca entity Employee --fields "name:string,email:string"`
2. **Generate Use Cases**: `goca usecase EmployeeService --entity Employee`
3. **Generate Repository**: `goca repository Employee --database postgres`
4. **Generate Handlers**: `goca handler Employee --type http`
5. **Generate DI**: `goca di --features Employee`

## ğŸ“š Commands by Layer

### ğŸŸ¡ Domain Layer

#### `goca entity`
Generates pure domain entities following DDD.
```bash
goca entity <name> [flags]

# Flags:
--fields string     Entity fields "name:type,email:string"
--validation       Add domain validations
--business-rules   Include business rule methods
```

**Example:**
```bash
goca entity Product --fields "name:string,price:float64,category:string" --validation --business-rules
```

**Generated Code:**
```go
// domain/product.go
package domain

type Product struct {
    ID       int
    Name     string
    Price    float64
    Category string
}

func (p *Product) Validate() error {
    if p.Name == "" || p.Price <= 0 {
        return ErrInvalidProductData
    }
    return nil
}

func (p *Product) IsExpensive() bool {
    return p.Price > 1000.0
}
```

### ğŸ”´ Use Case Layer

#### `goca usecase`
Generates application services with DTOs and business logic.
```bash
goca usecase <name> [flags]

# Flags:
--entity string    Associated entity
--operations string CRUD operations (create,read,update,delete,list)
--dto-validation   DTOs with specific validations
```

**Example:**
```bash
goca usecase ProductService --entity Product --operations "create,read,update,delete,list" --dto-validation
```

**Generated Code:**
```go
// usecase/product_service.go
package usecase

import "myproject/domain"

type CreateProductInput struct {
    Name     string `validate:"required,min=3"`
    Price    float64 `validate:"required,gt=0"`
    Category string `validate:"required"`
}

type CreateProductOutput struct {
    Product domain.Product
    Message string
}

type ProductUseCase interface {
    CreateProduct(input CreateProductInput) (CreateProductOutput, error)
    GetProduct(id int) (domain.Product, error)
    UpdateProduct(id int, input UpdateProductInput) error
    DeleteProduct(id int) error
    ListProducts() ([]domain.Product, error)
}
```

### ğŸŸ¢ Adapter Layer (Handlers)

#### `goca handler`
Generates delivery adapters for different protocols.
```bash
goca handler <entity> [flags]

# Flags:
--type string     Handler type (http, grpc, cli, worker, soap)
--middleware      Include middleware setup
--validation      Input validation in handler
```

**HTTP Example:**
```bash
goca handler Product --type http --middleware --validation
```

**Generated Code:**
```go
// handler/http/product_handler.go
package http

import (
    "encoding/json"
    "net/http"
    "myproject/usecase"
)

type ProductHandler struct {
    usecase usecase.ProductUseCase
}

func NewProductHandler(uc usecase.ProductUseCase) *ProductHandler {
    return &ProductHandler{usecase: uc}
}

func (h *ProductHandler) CreateProduct(w http.ResponseWriter, r *http.Request) {
    var input usecase.CreateProductInput
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    output, err := h.usecase.CreateProduct(input)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(output)
}
```

### ğŸ”µ Infrastructure Layer

#### `goca repository`
Generates repositories with interfaces and implementations.
```bash
goca repository <entity> [flags]

# Flags:
--database string  Database type (postgres, mysql, mongodb)
--interface-only   Generate interfaces only
--implementation   Generate implementation only
```

**Example:**
```bash
goca repository Product --database postgres
```

**Generated Code:**
```go
// repository/interfaces/product_repository.go
package interfaces

import "myproject/domain"

type ProductRepository interface {
    Save(product *domain.Product) error
    FindByID(id int) (*domain.Product, error)
    FindAll() ([]domain.Product, error)
    Update(product *domain.Product) error
    Delete(id int) error
}

// repository/postgres/product_repository.go
package postgres

import (
    "database/sql"
    "myproject/domain"
    "myproject/repository/interfaces"
)

type postgresProductRepository struct {
    db *sql.DB
}

func NewPostgresProductRepository(db *sql.DB) interfaces.ProductRepository {
    return &postgresProductRepository{db: db}
}

func (r *postgresProductRepository) Save(product *domain.Product) error {
    query := `INSERT INTO products (name, price, category) VALUES ($1, $2, $3) RETURNING id`
    err := r.db.QueryRow(query, product.Name, product.Price, product.Category).Scan(&product.ID)
    return err
}
```

### Auxiliary Commands

#### `goca messages`
Generates message and constant files.
```bash
goca messages <entity> [flags]

# Flags:
--errors       Generate error messages
--responses    Generate response messages
--constants    Generate feature constants
```

## ğŸ“ Complete Structure per Feature (Example: Employee)

```
employee/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ employee.go          # Pure entity
â”‚   â”œâ”€â”€ errors.go           # Domain errors
â”‚   â””â”€â”€ validations.go      # Business validations
â”œâ”€â”€ usecase/
â”‚   â”œâ”€â”€ dto.go              # Input/output DTOs
â”‚   â”œâ”€â”€ employee_usecase.go # Use case interface
â”‚   â”œâ”€â”€ employee_service.go # Use case implementation
â”‚   â””â”€â”€ interfaces.go       # Contracts to other layers
â”œâ”€â”€ repository/
â”‚   â”œâ”€â”€ interfaces.go       # Persistence contracts
â”‚   â”œâ”€â”€ postgres_employee_repo.go  # PostgreSQL implementation
â”‚   â””â”€â”€ memory_employee_repo.go    # In-memory implementation
â”œâ”€â”€ handler/
â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”œâ”€â”€ dto.go          # HTTP-specific DTOs
â”‚   â”‚   â””â”€â”€ handler.go      # HTTP controller
â”‚   â”œâ”€â”€ grpc/
â”‚   â”‚   â”œâ”€â”€ employee.proto  # gRPC definition
â”‚   â”‚   â””â”€â”€ server.go       # gRPC server
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â””â”€â”€ commands.go     # CLI commands
â”‚   â”œâ”€â”€ worker/
â”‚   â”‚   â””â”€â”€ worker.go       # Workers/Jobs
â”‚   â””â”€â”€ soap/
â”‚       â””â”€â”€ soap_client.go  # SOAP client
â”œâ”€â”€ messages/
â”‚   â”œâ”€â”€ errors.go           # Error messages
â”‚   â””â”€â”€ responses.go        # Response messages
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ constants.go        # Feature constants
â””â”€â”€ main.go                 # Entry point
```

## ğŸ“‹ Best vs Bad Practices by Layer

### ğŸŸ¡ Domain - What to DO and NOT do

#### âœ… Best Practices:
```go
// âœ… Pure entity with business validations
type Employee struct {
    ID    int
    Name  string
    Email string
    Role  string
}

func (e *Employee) Validate() error {
    if e.Name == "" || e.Email == "" {
        return ErrInvalidEmployeeData
    }
    return nil
}

func (e *Employee) IsManager() bool {
    return e.Role == "manager"
}
```

#### âŒ Bad Practices:
```go
// âŒ NEVER: Infrastructure dependencies in domain
type Employee struct {
    ID int
    DB *sql.DB // âŒ External dependency
}

// âŒ NEVER: Technical logic in domain
func (e *Employee) SaveToDatabase() error // âŒ Wrong responsibility

// âŒ NEVER: Import packages from external layers
import "myproject/handler/http" // âŒ Dependency violation
```

### ğŸ”´ Use Cases - What to DO and NOT do

#### âœ… Best Practices:
```go
// âœ… Well-defined DTOs
type CreateEmployeeInput struct {
    Name  string `validate:"required"`
    Email string `validate:"required,email"`
}

// âœ… Interfaces to other layers
type EmployeeRepository interface {
    Save(*domain.Employee) error
}

// âœ… Pure application logic
func (s *EmployeeService) CreateEmployee(input CreateEmployeeInput) error {
    emp := domain.Employee{Name: input.Name, Email: input.Email}
    if err := emp.Validate(); err != nil {
        return err
    }
    return s.repo.Save(&emp)
}
```

#### âŒ Bad Practices:
```go
// âŒ NEVER: Direct infrastructure dependencies
func (s *EmployeeService) CreateEmployee(db *sql.DB) error // âŒ Coupling

// âŒ NEVER: Presentation logic
func (s *EmployeeService) CreateEmployeeJSON() string // âŒ Wrong responsibility

// âŒ NEVER: Implementation details
func (s *EmployeeService) CreateEmployeeWithPostgres() error // âŒ Technical specificity
```

### ğŸŸ¢ Adapters - What to DO and NOT do

#### âœ… Best Practices:
```go
// âœ… Data transformation only
func (h *EmployeeHandler) CreateEmployee(w http.ResponseWriter, r *http.Request) {
    var httpInput HTTPCreateEmployeeInput
    json.NewDecoder(r.Body).Decode(&httpInput)
    
    usecaseInput := usecase.CreateEmployeeInput{
        Name:  httpInput.Name,
        Email: httpInput.Email,
    }
    
    err := h.usecase.CreateEmployee(usecaseInput)
    // Handle HTTP response
}
```

#### âŒ Bad Practices:
```go
// âŒ NEVER: Business logic in handlers
func (h *EmployeeHandler) CreateEmployee(w http.ResponseWriter, r *http.Request) {
    // âŒ Business validations here
    if employee.Salary < 0 {
        return errors.New("invalid salary")
    }
}

// âŒ NEVER: Direct repository access
func (h *EmployeeHandler) CreateEmployee(repo EmployeeRepository) // âŒ Skip use cases
```

### ğŸ”µ Infrastructure - What to DO and NOT do

#### âœ… Best Practices:
```go
// âœ… Specific persistence implementation
func (r *PostgresEmployeeRepo) Save(emp *domain.Employee) error {
    query := "INSERT INTO employees (name, email) VALUES ($1, $2)"
    _, err := r.db.Exec(query, emp.Name, emp.Email)
    return err
}

// âœ… Implement domain interfaces
func NewPostgresEmployeeRepo(db *sql.DB) domain.EmployeeRepository {
    return &PostgresEmployeeRepo{db: db}
}
```

#### âŒ Bad Practices:
```go
// âŒ NEVER: Expose specific DB types
func (r *PostgresEmployeeRepo) GetDB() *sql.DB // âŒ Technical detail exposed

// âŒ NEVER: Business logic in repositories
func (r *PostgresEmployeeRepo) ValidateAndSave(emp *domain.Employee) error {
    if emp.Salary < 0 { // âŒ Business validation here
        return errors.New("invalid salary")
    }
}
```

## ğŸ”§ Advanced Commands

### Generate Complete Feature
```bash
# Generates all layers for a feature
goca feature <name> --fields "field:type,..." --database postgres --handlers "http,grpc,cli"
```

### Generate Interfaces Only
```bash
# Useful for TDD - generate contracts first
goca interfaces Product --usecase --repository
```

### Generate Dependency Injection
```bash
# Generates DI container for automatic wiring
goca di --features "Product,User,Order"
```

## ğŸ¯ Advantages of Each Layer

### ğŸŸ¡ Domain
- **Pure entities** without external dependencies
- **Business rules** centralized and testable
- **Domain-specific validations**

### ğŸ”´ Use Cases
- **Specific DTOs** for each operation
- **Well-defined application logic**
- **Clear interfaces** to other layers

### ğŸŸ¢ Adapters
- **Complete separation** between input protocols
- **Protocol-specific input validations**
- **Transformation** from external to internal DTOs

### ğŸ”µ Infrastructure
- **Interchangeable implementations** of persistence
- **Isolation** of technical details
- **Centralized configuration** of external resources

## ğŸ”„ Dependency Flow

```
Handler â†’ UseCase â†’ Repository â†’ Database
   â†“         â†“         â†“
 DTO â†â†’ Business â†â†’ Domain Entity
```

**Golden Rule**: Dependencies always point inward, towards the domain.

## ğŸ“š Complete Documentation

### Configuration System
- **[Quick Start Config](docs/QUICKSTART_CONFIG.md)** - Get started with `.goca.yaml` in 5 minutes
- **[YAML Structure Reference](docs/YAML_STRUCTURE_REFERENCE.md)** - Complete reference for all configuration options
- **[Configuration System Guide](docs/configuration-system.md)** - Detailed configuration documentation
- **[Migration Guide](docs/migration-guide.md)** - Migrate from pure CLI to configuration files

### Integration & Status
- **[Production Ready Report](docs/PRODUCTION_READY_FINAL_REPORT.md)** - 100% production readiness verification
- **[Configuration Integration Complete](docs/CONFIGURATION_INTEGRATION_COMPLETE.md)** - Integration status and technical details

### Advanced Topics
- **[Advanced Configuration](docs/advanced-config.md)** - Advanced configuration commands and patterns
- **[Complete Tutorial](wiki/Complete-Tutorial.md)** - Step-by-step tutorial for full project setup

## ğŸ¤ Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/clean-arch-enhancement`)
3. Commit your changes (`git commit -m 'Add enhanced clean architecture layer'`)
4. Push to the branch (`git push origin feature/clean-arch-enhancement`)
5. Open a Pull Request

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ†˜ Support

- ğŸ“§ Email: support@goca.dev
- ğŸ› Issues: [GitHub Issues](https://github.com/sazardev/goca/issues)
- ğŸ“– Documentation: [Complete Documentation](https://docs.goca.dev)

---

Built with â¤ï¸ for the Go community