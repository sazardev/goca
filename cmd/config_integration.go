package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// ConfigIntegration handles integration between YAML config and CLI commands
type ConfigIntegration struct {
	manager         *ConfigManager
	config          *GocaConfig
	templateManager *TemplateManager
	projectPath     string
}

// NewConfigIntegration creates a new configuration integration handler
func NewConfigIntegration() *ConfigIntegration {
	return &ConfigIntegration{
		manager: NewConfigManager(),
	}
}

// LoadConfigForProject loads configuration for current project context
func (ci *ConfigIntegration) LoadConfigForProject() error {
	// Get current working directory
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	ci.projectPath = wd

	// Load configuration
	if err := ci.manager.LoadConfig(wd); err != nil {
		return fmt.Errorf("failed to load configuration: %w", err)
	}

	ci.config = ci.manager.GetConfig()

	// Initialize template manager if configuration is available
	if ci.config != nil {
		ci.templateManager = NewTemplateManager(&ci.config.Templates, wd)
		if err := ci.templateManager.LoadTemplates(); err != nil {
			// Don't fail if templates can't be loaded, just warn
			fmt.Printf("Warning: Could not load custom templates: %v\n", err)
		}
	}

	return nil
}

// GetDatabaseType returns database type with fallback to CLI flag
func (ci *ConfigIntegration) GetDatabaseType(cliFlag string) string {
	if cliFlag != "" {
		return cliFlag
	}

	if ci.config != nil {
		return ci.config.Database.Type
	}

	return "postgres" // default
}

// GetHandlerTypes returns handler types with fallback to CLI flag
func (ci *ConfigIntegration) GetHandlerTypes(cliFlag string) []string {
	if cliFlag != "" {
		return strings.Split(cliFlag, ",")
	}

	if ci.config != nil {
		handlers := make([]string, 0)
		if ci.config.Architecture.Layers.Handler.Enabled {
			handlers = append(handlers, "http")
		}
		return handlers
	}

	return []string{"http"} // default
}

// GetValidationEnabled returns validation setting with fallback to CLI flag
func (ci *ConfigIntegration) GetValidationEnabled(cliFlag *bool) bool {
	if cliFlag != nil {
		return *cliFlag
	}

	if ci.config != nil {
		return ci.config.Generation.Validation.Enabled
	}

	return true // default
}

// GetBusinessRulesEnabled returns business rules setting with fallback to CLI flag
func (ci *ConfigIntegration) GetBusinessRulesEnabled(cliFlag *bool) bool {
	if cliFlag != nil {
		return *cliFlag
	}

	if ci.config != nil {
		return ci.config.Generation.BusinessRules.Enabled
	}

	return false // default
}

// GetProjectConfig returns project configuration for generation
func (ci *ConfigIntegration) GetProjectConfig() ProjectConfig {
	if ci.config != nil {
		return ci.config.Project
	}

	// Return default project config
	wd, _ := os.Getwd()
	projectName := filepath.Base(wd)

	return ProjectConfig{
		Name:        projectName,
		Module:      fmt.Sprintf("github.com/example/%s", projectName),
		Description: fmt.Sprintf("Generated by Goca CLI - %s", projectName),
		Version:     "1.0.0",
		License:     "MIT",
	}
}

// GetArchitectureConfig returns architecture configuration
func (ci *ConfigIntegration) GetArchitectureConfig() ArchitectureConfig {
	if ci.config != nil {
		return ci.config.Architecture
	}

	// Return default architecture config
	return ArchitectureConfig{
		Layers: LayersConfig{
			Domain:     LayerConfig{Enabled: true, Directory: "internal/domain"},
			UseCase:    LayerConfig{Enabled: true, Directory: "internal/usecase"},
			Repository: LayerConfig{Enabled: true, Directory: "internal/repository"},
			Handler:    LayerConfig{Enabled: true, Directory: "internal/handler"},
		},
		Patterns: []string{"repository", "factory"},
		DI: DIConfig{
			Type:     "manual",
			AutoWire: true,
		},
		Naming: NamingConfig{
			Entities:  "PascalCase",
			Fields:    "PascalCase",
			Files:     "snake_case",
			Packages:  "lowercase",
			Constants: "UPPER_CASE",
			Variables: "camelCase",
			Functions: "PascalCase",
		},
	}
}

// GetDatabaseConfig returns database configuration
func (ci *ConfigIntegration) GetDatabaseConfig() DatabaseConfig {
	if ci.config != nil {
		return ci.config.Database
	}

	// Return default database config
	return DatabaseConfig{
		Type: "postgres",
		Port: 5432,
		Migrations: MigrationConfig{
			Enabled:      true,
			AutoGenerate: true,
			Directory:    "migrations",
			Naming:       "timestamp",
			Versioning:   "sequential",
		},
		Features: DatabaseFeatureConfig{
			SoftDelete: true,
			Timestamps: true,
			UUID:       false,
			Audit:      false,
		},
	}
}

// GetGenerationConfig returns generation configuration
func (ci *ConfigIntegration) GetGenerationConfig() GenerationConfig {
	if ci.config != nil {
		return ci.config.Generation
	}

	// Return default generation config
	return GenerationConfig{
		Validation: ValidationConfig{
			Enabled: true,
			Library: "builtin",
			Tags:    []string{"required", "min", "max", "email"},
		},
		BusinessRules: BusinessRulesConfig{
			Enabled:  false,
			Patterns: []string{},
		},
		Style: StyleConfig{
			Gofmt:      true,
			Goimports:  true,
			LineLength: 120,
			TabWidth:   4,
		},
	}
}

// GetTestingConfig returns testing configuration
func (ci *ConfigIntegration) GetTestingConfig() TestingConfig {
	if ci.config != nil {
		return ci.config.Testing
	}

	// Return default testing config
	return TestingConfig{
		Enabled:     true,
		Framework:   "testify",
		Integration: true,
		Coverage: CoverageConfig{
			Enabled:   true,
			Threshold: 80.0,
		},
	}
}

// GetTemplateConfig returns template configuration
func (ci *ConfigIntegration) GetTemplateConfig() TemplateConfig {
	if ci.config != nil {
		return ci.config.Templates
	}

	// Return default template config
	return TemplateConfig{
		Directory: ".goca/templates",
		Variables: map[string]string{
			"author":  "Goca CLI",
			"license": "MIT",
		},
	}
}

// GetFeatureConfig returns feature configuration
func (ci *ConfigIntegration) GetFeatureConfig() FeatureConfig {
	if ci.config != nil {
		return ci.config.Features
	}

	// Return default feature config
	return FeatureConfig{
		Auth: AuthConfig{
			Enabled: false,
		},
		Logging: LoggingConfig{
			Enabled: true,
			Level:   "info",
			Format:  "json",
		},
		Security: SecurityConfig{
			HTTPS:      true,
			Validation: true,
		},
	}
}

// MergeWithCLIFlags merges configuration with CLI flags
func (ci *ConfigIntegration) MergeWithCLIFlags(flags map[string]interface{}) {
	if ci.manager != nil {
		ci.manager.MergeWithFlags(flags)
		ci.config = ci.manager.GetConfig()
	}
}

// PrintConfigSummary prints configuration summary if available
func (ci *ConfigIntegration) PrintConfigSummary() {
	if ci.manager != nil {
		ci.manager.PrintSummary()
	} else {
		fmt.Println("Using default configuration (.goca.yaml not found)")
	}
}

// HasConfigFile returns true if a config file was loaded
func (ci *ConfigIntegration) HasConfigFile() bool {
	return ci.config != nil && ci.manager.filePath != ""
}

// GetConfigPath returns the path of the loaded config file
func (ci *ConfigIntegration) GetConfigPath() string {
	if ci.manager != nil {
		return ci.manager.filePath
	}
	return ""
}

// ValidateConfiguration validates current configuration
func (ci *ConfigIntegration) ValidateConfiguration() error {
	if ci.manager == nil {
		return nil // No config to validate
	}

	errors := ci.manager.GetErrors()
	if len(errors) > 0 {
		return fmt.Errorf("configuration has %d errors", len(errors))
	}

	return nil
}

// GetValidationErrors returns configuration validation errors
func (ci *ConfigIntegration) GetValidationErrors() []ConfigError {
	if ci.manager == nil {
		return nil
	}
	return ci.manager.GetErrors()
}

// GetValidationWarnings returns configuration validation warnings
func (ci *ConfigIntegration) GetValidationWarnings() []ConfigWarning {
	if ci.manager == nil {
		return nil
	}
	return ci.manager.GetWarnings()
}

// GenerateConfigFile generates a .goca.yaml file in the specified project directory
func (ci *ConfigIntegration) GenerateConfigFile(projectPath, projectName, module, database string) error {
	if ci.manager == nil {
		ci.manager = NewConfigManager()
	}

	return ci.manager.GenerateDefaultConfig(projectPath, projectName, module, database)
}

// UpdateConfigFromTemplate updates configuration based on template data
func (ci *ConfigIntegration) UpdateConfigFromTemplate(templateData map[string]interface{}) {
	if ci.config == nil {
		return
	}

	// Update project information from template data
	if projectName, ok := templateData["ProjectName"].(string); ok && projectName != "" {
		ci.config.Project.Name = projectName
	}

	if module, ok := templateData["Module"].(string); ok && module != "" {
		ci.config.Project.Module = module
	}

	if dbType, ok := templateData["DatabaseType"].(string); ok && dbType != "" {
		ci.config.Database.Type = dbType
	}
}

// GetTemplateData returns template data enriched with configuration
func (ci *ConfigIntegration) GetTemplateData(baseData map[string]interface{}) map[string]interface{} {
	if ci.config == nil {
		return baseData
	}

	// Enrich template data with configuration values
	baseData["ProjectConfig"] = ci.config.Project
	baseData["ArchConfig"] = ci.config.Architecture
	baseData["DatabaseConfig"] = ci.config.Database
	baseData["GenerationConfig"] = ci.config.Generation
	baseData["TestingConfig"] = ci.config.Testing
	baseData["FeatureConfig"] = ci.config.Features

	// Add commonly used configuration values
	baseData["ValidationEnabled"] = ci.config.Generation.Validation.Enabled
	baseData["BusinessRulesEnabled"] = ci.config.Generation.BusinessRules.Enabled
	baseData["SoftDeleteEnabled"] = ci.config.Database.Features.SoftDelete
	baseData["TimestampsEnabled"] = ci.config.Database.Features.Timestamps
	baseData["AuthEnabled"] = ci.config.Features.Auth.Enabled
	baseData["TestingEnabled"] = ci.config.Testing.Enabled

	return baseData
}

// UpdateConfigAfterGeneration updates configuration after generating files
func (ci *ConfigIntegration) UpdateConfigAfterGeneration(feature, entityName string) {
	if ci.config == nil {
		return
	}

	// Update feature history or tracking
	// This could be used for future analytics or recommendations
}

// GetNamingConvention returns naming convention for different types
func (ci *ConfigIntegration) GetNamingConvention(elementType string) string {
	if ci.config == nil {
		// Return defaults
		switch elementType {
		case "entity":
			return "PascalCase"
		case "field":
			return "PascalCase"
		case "file":
			return "snake_case"
		case "package":
			return "lowercase"
		default:
			return "PascalCase"
		}
	}

	switch elementType {
	case "entity":
		return ci.config.Architecture.Naming.Entities
	case "field":
		return ci.config.Architecture.Naming.Fields
	case "file":
		return ci.config.Architecture.Naming.Files
	case "package":
		return ci.config.Architecture.Naming.Packages
	case "constant":
		return ci.config.Architecture.Naming.Constants
	case "variable":
		return ci.config.Architecture.Naming.Variables
	case "function":
		return ci.config.Architecture.Naming.Functions
	default:
		return ci.config.Architecture.Naming.Entities
	}
}

// GetTemplateManager returns the template manager
func (ci *ConfigIntegration) GetTemplateManager() *TemplateManager {
	return ci.templateManager
}

// HasCustomTemplate checks if a custom template exists
func (ci *ConfigIntegration) HasCustomTemplate(templateName string) bool {
	if ci.templateManager == nil {
		return false
	}
	return ci.templateManager.HasTemplate(templateName)
}

// ExecuteCustomTemplate executes a custom template if available
func (ci *ConfigIntegration) ExecuteCustomTemplate(templateName string, data map[string]interface{}) (string, error) {
	if ci.templateManager == nil {
		return "", fmt.Errorf("template manager not initialized")
	}

	return ci.templateManager.ExecuteTemplate(templateName, data)
}

// GetAvailableTemplates returns list of available custom templates
func (ci *ConfigIntegration) GetAvailableTemplates() []string {
	if ci.templateManager == nil {
		return []string{}
	}
	return ci.templateManager.GetAvailableTemplates()
}

// InitializeTemplateSystem sets up templates for the first time
func (ci *ConfigIntegration) InitializeTemplateSystem() error {
	if ci.config == nil || ci.projectPath == "" {
		return fmt.Errorf("configuration or project path not set")
	}

	// Create template manager
	ci.templateManager = NewTemplateManager(&ci.config.Templates, ci.projectPath)

	// This will create default templates if directory doesn't exist
	if err := ci.templateManager.LoadTemplates(); err != nil {
		return fmt.Errorf("failed to initialize templates: %w", err)
	}

	fmt.Printf("Template system initialized in: %s\n", ci.config.Templates.Directory)
	fmt.Printf("Available templates: %v\n", ci.templateManager.GetAvailableTemplates())

	return nil
}

// GenerateProjectDocumentation generates project documentation using templates
func (ci *ConfigIntegration) GenerateProjectDocumentation() error {
	if ci.templateManager == nil || !ci.templateManager.HasTemplate("docs/README") {
		// No custom template, skip
		return nil
	}

	// Prepare data for documentation template
	data := ci.GetTemplateData(map[string]interface{}{
		"ProjectName":  ci.config.Project.Name,
		"Description":  ci.config.Project.Description,
		"Version":      ci.config.Project.Version,
		"DatabaseType": ci.config.Database.Type,
	})

	// Execute template
	content, err := ci.templateManager.ExecuteTemplate("docs/README", data)
	if err != nil {
		return fmt.Errorf("failed to execute README template: %w", err)
	}

	// Write to README.md
	readmePath := filepath.Join(ci.projectPath, "README.md")
	if err := os.WriteFile(readmePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write README.md: %w", err)
	}

	fmt.Printf("📖 Generated enhanced README.md using custom template\n")
	return nil
}
