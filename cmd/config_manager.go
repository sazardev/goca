package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// ConfigManager handles loading, validation, and management of Goca configuration
type ConfigManager struct {
	config   *GocaConfig
	filePath string
	errors   []ConfigError
	warnings []ConfigWarning
}

// ConfigError represents a configuration error
type ConfigError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
	Value   string `json:"value"`
	Line    int    `json:"line,omitempty"`
	Column  int    `json:"column,omitempty"`
}

// ConfigWarning represents a configuration warning
type ConfigWarning struct {
	Field      string `json:"field"`
	Message    string `json:"message"`
	Value      string `json:"value"`
	Suggestion string `json:"suggestion"`
}

// NewConfigManager creates a new configuration manager
func NewConfigManager() *ConfigManager {
	return &ConfigManager{
		config:   nil,
		errors:   make([]ConfigError, 0),
		warnings: make([]ConfigWarning, 0),
	}
}

// LoadConfig loads configuration from file or creates default
func (cm *ConfigManager) LoadConfig(projectPath string) error {
	configPath := cm.findConfigFile(projectPath)

	if configPath == "" {
		// No config file found, create default
		cm.config = cm.createDefaultConfig(projectPath)
		return nil
	}

	cm.filePath = configPath
	return cm.loadFromFile(configPath)
}

// findConfigFile searches for configuration file in project
func (cm *ConfigManager) findConfigFile(projectPath string) string {
	candidates := []string{
		".goca.yaml",
		".goca.yml",
		"goca.yaml",
		"goca.yml",
		".config/goca.yaml",
		"config/goca.yaml",
	}

	for _, candidate := range candidates {
		fullPath := filepath.Join(projectPath, candidate)
		if _, err := os.Stat(fullPath); err == nil {
			return fullPath
		}
	}

	return ""
}

// loadFromFile loads and validates configuration from YAML file
func (cm *ConfigManager) loadFromFile(filePath string) error {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read config file %s: %w", filePath, err)
	}

	// Parse YAML
	config := &GocaConfig{}
	if err := yaml.Unmarshal(data, config); err != nil {
		return fmt.Errorf("failed to parse config file %s: %w", filePath, err)
	}

	// Validate configuration
	if err := cm.validateConfig(config); err != nil {
		return fmt.Errorf("invalid configuration: %w", err)
	}

	// Apply defaults for missing values
	cm.applyDefaults(config)

	cm.config = config
	return nil
}

// createDefaultConfig creates a default configuration
func (cm *ConfigManager) createDefaultConfig(projectPath string) *GocaConfig {
	projectName := filepath.Base(projectPath)
	if projectName == "." || projectName == "" {
		projectName = "goca-project"
	}

	return &GocaConfig{
		Project: ProjectConfig{
			Name:        projectName,
			Module:      fmt.Sprintf("github.com/example/%s", projectName),
			Description: fmt.Sprintf("Generated by Goca CLI - %s", projectName),
			Version:     "1.0.0",
			License:     "MIT",
			Tags:        []string{"clean-architecture", "go", "api"},
		},
		Architecture: ArchitectureConfig{
			Layers: LayersConfig{
				Domain:     LayerConfig{Enabled: true, Directory: "internal/domain"},
				UseCase:    LayerConfig{Enabled: true, Directory: "internal/usecase"},
				Repository: LayerConfig{Enabled: true, Directory: "internal/repository"},
				Handler:    LayerConfig{Enabled: true, Directory: "internal/handler"},
			},
			Patterns: []string{"repository", "factory"},
			DI: DIConfig{
				Type:     "manual",
				AutoWire: true,
			},
			Naming: NamingConfig{
				Entities:  "PascalCase",
				Fields:    "PascalCase",
				Files:     "snake_case",
				Packages:  "lowercase",
				Constants: "UPPER_CASE",
				Variables: "camelCase",
				Functions: "PascalCase",
			},
		},
		Database: DatabaseConfig{
			Type: "postgres",
			Port: 5432,
			Name: projectName,
			Migrations: MigrationConfig{
				Enabled:      true,
				AutoGenerate: true,
				Directory:    "migrations",
				Naming:       "timestamp",
				Versioning:   "sequential",
			},
			Connection: ConnectionConfig{
				MaxOpen:     25,
				MaxIdle:     10,
				MaxLifetime: 5 * time.Minute,
				SSLMode:     "require",
				Timezone:    "UTC",
			},
			Features: DatabaseFeatureConfig{
				SoftDelete: true,
				Timestamps: true,
				UUID:       false,
				Audit:      false,
			},
		},
		Generation: GenerationConfig{
			Validation: ValidationConfig{
				Enabled: true,
				Library: "builtin",
				Tags:    []string{"required", "min", "max", "email"},
			},
			BusinessRules: BusinessRulesConfig{
				Enabled:  false,
				Patterns: []string{},
				Events:   false,
				Guards:   false,
			},
			Documentation: DocumentationConfig{
				Swagger: SwaggerConfig{
					Enabled:     true,
					Version:     "3.0.0",
					Output:      "docs/swagger.yaml",
					Title:       fmt.Sprintf("%s API", strings.Title(projectName)),
					Description: fmt.Sprintf("API documentation for %s", projectName),
					Host:        "localhost:8080",
					BasePath:    "/api/v1",
					Schemes:     []string{"http", "https"},
				},
				Comments: CommentsConfig{
					Enabled:  true,
					Language: "spanish",
					Style:    "godoc",
					Examples: true,
				},
			},
			Style: StyleConfig{
				Gofmt:      true,
				Goimports:  true,
				Golint:     true,
				Govet:      true,
				LineLength: 120,
				TabWidth:   4,
			},
			Imports: ImportConfig{
				GroupStandard:   true,
				GroupThirdParty: true,
				GroupLocal:      true,
				SortAlpha:       true,
				RemoveUnused:    true,
			},
		},
		Testing: TestingConfig{
			Enabled:     true,
			Framework:   "testify",
			Integration: true,
			Benchmarks:  false,
			Examples:    true,
			Coverage: CoverageConfig{
				Enabled:   true,
				Threshold: 80.0,
				Format:    "html",
			},
			Mocks: MockConfig{
				Enabled:   true,
				Tool:      "testify",
				Directory: "mocks",
				Suffix:    "_mock",
			},
			Fixtures: FixtureConfig{
				Enabled:   true,
				Directory: "testdata",
				Format:    "yaml",
				Seeds:     true,
			},
		},
		Templates: TemplateConfig{
			Directory: ".goca/templates",
			Variables: map[string]string{
				"author":  "Goca CLI",
				"license": "MIT",
				"year":    fmt.Sprintf("%d", time.Now().Year()),
			},
		},
		Features: FeatureConfig{
			Auth: AuthConfig{
				Enabled:    false,
				Type:       "jwt",
				RBAC:       false,
				Middleware: true,
			},
			Cache: CacheConfig{
				Enabled: false,
				Type:    "redis",
				TTL:     "1h",
			},
			Logging: LoggingConfig{
				Enabled:    true,
				Level:      "info",
				Format:     "json",
				Output:     []string{"stdout"},
				Structured: true,
			},
			Monitoring: MonitoringConfig{
				Enabled:     false,
				Metrics:     false,
				Tracing:     false,
				HealthCheck: true,
			},
			Security: SecurityConfig{
				HTTPS:        true,
				CORS:         true,
				RateLimit:    false,
				Validation:   true,
				Sanitization: true,
			},
		},
		Deploy: DeployConfig{
			Docker: DockerConfig{
				Enabled:    true,
				Dockerfile: "Dockerfile",
				Multistage: true,
			},
			Kubernetes: KubernetesConfig{
				Enabled:   false,
				Namespace: projectName,
				Manifests: "k8s",
			},
			CI: CIConfig{
				Enabled:  false,
				Provider: "github-actions",
				Tests:    true,
				Build:    true,
				Deploy:   false,
			},
		},
	}
}

// validateConfig validates the configuration and collects errors/warnings
func (cm *ConfigManager) validateConfig(config *GocaConfig) error {
	cm.errors = make([]ConfigError, 0)
	cm.warnings = make([]ConfigWarning, 0)

	// Validate project configuration
	cm.validateProject(&config.Project)

	// Validate architecture configuration
	cm.validateArchitecture(&config.Architecture)

	// Validate database configuration
	cm.validateDatabase(&config.Database)

	// Validate generation configuration
	cm.validateGeneration(&config.Generation)

	// Validate testing configuration
	cm.validateTesting(&config.Testing)

	// Validate features configuration
	cm.validateFeatures(&config.Features)

	// If we have critical errors, return them
	if len(cm.errors) > 0 {
		return fmt.Errorf("configuration validation failed with %d errors", len(cm.errors))
	}

	return nil
}

// validateProject validates project configuration
func (cm *ConfigManager) validateProject(project *ProjectConfig) {
	if project.Name == "" {
		cm.addError("project.name", "project name is required", "")
	}

	if project.Module == "" {
		cm.addError("project.module", "module name is required", "")
	}

	if project.Version == "" {
		cm.addWarning("project.version", "version not specified", "", "1.0.0")
	}
}

// validateArchitecture validates architecture configuration
func (cm *ConfigManager) validateArchitecture(arch *ArchitectureConfig) {
	// Validate naming conventions
	validNamings := []string{"PascalCase", "camelCase", "snake_case", "kebab-case", "UPPER_CASE", "lowercase"}

	if !cm.isValidNaming(arch.Naming.Entities, validNamings) {
		cm.addError("architecture.naming.entities", "invalid naming convention", arch.Naming.Entities)
	}

	if !cm.isValidNaming(arch.Naming.Fields, validNamings) {
		cm.addError("architecture.naming.fields", "invalid naming convention", arch.Naming.Fields)
	}

	// Validate DI type
	validDITypes := []string{"manual", "wire", "fx", "dig"}
	if !cm.contains(validDITypes, arch.DI.Type) {
		cm.addError("architecture.di.type", "invalid DI type", arch.DI.Type)
	}
}

// validateDatabase validates database configuration
func (cm *ConfigManager) validateDatabase(db *DatabaseConfig) {
	validDBTypes := []string{"postgres", "mysql", "mongodb", "sqlite"}
	if !cm.contains(validDBTypes, db.Type) {
		cm.addError("database.type", "invalid database type", db.Type)
	}

	if db.Port <= 0 || db.Port > 65535 {
		cm.addError("database.port", "invalid port number", fmt.Sprintf("%d", db.Port))
	}

	if db.Connection.MaxOpen <= 0 {
		cm.addWarning("database.connection.max_open", "max_open should be > 0", fmt.Sprintf("%d", db.Connection.MaxOpen), "25")
	}
}

// validateGeneration validates generation configuration
func (cm *ConfigManager) validateGeneration(gen *GenerationConfig) {
	// Validate validation library
	validLibs := []string{"builtin", "validator", "ozzo-validation"}
	if !cm.contains(validLibs, gen.Validation.Library) {
		cm.addError("generation.validation.library", "invalid validation library", gen.Validation.Library)
	}

	// Validate style configuration
	if gen.Style.LineLength <= 0 {
		cm.addWarning("generation.style.line_length", "line_length should be > 0", fmt.Sprintf("%d", gen.Style.LineLength), "120")
	}
}

// validateTesting validates testing configuration
func (cm *ConfigManager) validateTesting(test *TestingConfig) {
	validFrameworks := []string{"testify", "ginkgo", "builtin"}
	if !cm.contains(validFrameworks, test.Framework) {
		cm.addError("testing.framework", "invalid testing framework", test.Framework)
	}

	if test.Coverage.Threshold < 0 || test.Coverage.Threshold > 100 {
		cm.addError("testing.coverage.threshold", "threshold must be between 0 and 100", fmt.Sprintf("%.1f", test.Coverage.Threshold))
	}
}

// validateFeatures validates features configuration
func (cm *ConfigManager) validateFeatures(features *FeatureConfig) {
	// Validate auth type
	if features.Auth.Enabled {
		validAuthTypes := []string{"jwt", "oauth2", "session", "basic"}
		if !cm.contains(validAuthTypes, features.Auth.Type) {
			cm.addError("features.auth.type", "invalid auth type", features.Auth.Type)
		}
	}

	// Validate cache type
	if features.Cache.Enabled {
		validCacheTypes := []string{"redis", "memcached", "inmemory"}
		if !cm.contains(validCacheTypes, features.Cache.Type) {
			cm.addError("features.cache.type", "invalid cache type", features.Cache.Type)
		}
	}
}

// applyDefaults applies default values for missing configuration
func (cm *ConfigManager) applyDefaults(config *GocaConfig) {
	// Apply defaults based on context and other settings
	if config.Database.Type == "postgres" && config.Database.Port == 0 {
		config.Database.Port = 5432
	}

	if config.Database.Type == "mysql" && config.Database.Port == 0 {
		config.Database.Port = 3306
	}

	if config.Database.Type == "mongodb" && config.Database.Port == 0 {
		config.Database.Port = 27017
	}

	// Set intelligent defaults based on project type
	if config.Features.Auth.Enabled && config.Features.Security.RateLimit == false {
		config.Features.Security.RateLimit = true
		cm.addWarning("features.security.rate_limit", "automatically enabled due to auth", "false", "true")
	}
}

// GetConfig returns the loaded configuration
func (cm *ConfigManager) GetConfig() *GocaConfig {
	return cm.config
}

// GetErrors returns configuration errors
func (cm *ConfigManager) GetErrors() []ConfigError {
	return cm.errors
}

// GetWarnings returns configuration warnings
func (cm *ConfigManager) GetWarnings() []ConfigWarning {
	return cm.warnings
}

// SaveConfig saves the current configuration to file
func (cm *ConfigManager) SaveConfig(filePath string) error {
	if cm.config == nil {
		return fmt.Errorf("no configuration loaded")
	}

	data, err := yaml.Marshal(cm.config)
	if err != nil {
		return fmt.Errorf("failed to marshal configuration: %w", err)
	}

	// Ensure directory exists
	dir := filepath.Dir(filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	if err := os.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write configuration file: %w", err)
	}

	cm.filePath = filePath
	return nil
}

// GenerateDefaultConfig generates a default .goca.yaml file
func (cm *ConfigManager) GenerateDefaultConfig(projectPath, projectName, module string) error {
	// Create default config with provided parameters
	config := cm.createDefaultConfig(projectPath)
	if projectName != "" {
		config.Project.Name = projectName
	}
	if module != "" {
		config.Project.Module = module
	}

	cm.config = config

	// Save to .goca.yaml in project root
	configPath := filepath.Join(projectPath, ".goca.yaml")
	return cm.SaveConfig(configPath)
}

// MergeWithFlags merges configuration with CLI flags
func (cm *ConfigManager) MergeWithFlags(flags map[string]interface{}) {
	if cm.config == nil {
		return
	}

	// Database flags
	if db, ok := flags["database"].(string); ok && db != "" {
		cm.config.Database.Type = db
	}

	// Handler flags
	if handlers, ok := flags["handlers"].(string); ok && handlers != "" {
		// Parse handlers and update configuration
		handlerList := strings.Split(handlers, ",")
		for _, handler := range handlerList {
			handler = strings.TrimSpace(handler)
			switch handler {
			case "http":
				cm.config.Architecture.Layers.Handler.Enabled = true
			case "grpc":
				// Enable gRPC specific configuration
			}
		}
	}

	// Auth flags
	if auth, ok := flags["auth"].(bool); ok {
		cm.config.Features.Auth.Enabled = auth
	}

	// Validation flags
	if validation, ok := flags["validation"].(bool); ok {
		cm.config.Generation.Validation.Enabled = validation
	}
}

// Helper methods

func (cm *ConfigManager) addError(field, message, value string) {
	cm.errors = append(cm.errors, ConfigError{
		Field:   field,
		Message: message,
		Value:   value,
	})
}

func (cm *ConfigManager) addWarning(field, message, value, suggestion string) {
	cm.warnings = append(cm.warnings, ConfigWarning{
		Field:      field,
		Message:    message,
		Value:      value,
		Suggestion: suggestion,
	})
}

func (cm *ConfigManager) isValidNaming(naming string, validOptions []string) bool {
	return cm.contains(validOptions, naming)
}

func (cm *ConfigManager) contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// PrintSummary prints configuration summary
func (cm *ConfigManager) PrintSummary() {
	if cm.config == nil {
		fmt.Println("❌ No configuration loaded")
		return
	}

	fmt.Printf("📋 Project Configuration: %s\n", cm.config.Project.Name)
	fmt.Printf("   📦 Módulo: %s\n", cm.config.Project.Module)
	fmt.Printf("   🗄️  Base de datos: %s\n", cm.config.Database.Type)
	fmt.Printf("   🏗️  Capas: %d habilitadas\n", cm.countEnabledLayers())
	fmt.Printf("   🧪 Tests: %t\n", cm.config.Testing.Enabled)

	if len(cm.warnings) > 0 {
		fmt.Printf("\n⚠️  Advertencias (%d):\n", len(cm.warnings))
		for _, warning := range cm.warnings {
			fmt.Printf("   - %s: %s\n", warning.Field, warning.Message)
		}
	}

	if len(cm.errors) > 0 {
		fmt.Printf("\n❌ Errores (%d):\n", len(cm.errors))
		for _, error := range cm.errors {
			fmt.Printf("   - %s: %s\n", error.Field, error.Message)
		}
	}
}

func (cm *ConfigManager) countEnabledLayers() int {
	count := 0
	if cm.config.Architecture.Layers.Domain.Enabled {
		count++
	}
	if cm.config.Architecture.Layers.UseCase.Enabled {
		count++
	}
	if cm.config.Architecture.Layers.Repository.Enabled {
		count++
	}
	if cm.config.Architecture.Layers.Handler.Enabled {
		count++
	}
	return count
}

// Testing Methods - Public wrappers for testing private functionality

// CreateDefaultConfig creates a default configuration (public for testing)
func (cm *ConfigManager) CreateDefaultConfig(projectPath string) *GocaConfig {
	return cm.createDefaultConfig(projectPath)
}

// ValidateConfig validates the configuration and collects errors/warnings (public for testing)
func (cm *ConfigManager) ValidateConfig(config *GocaConfig) error {
	return cm.validateConfig(config)
}

// FindConfigFile searches for configuration file in project (public for testing)
func (cm *ConfigManager) FindConfigFile(projectPath string) string {
	return cm.findConfigFile(projectPath)
}

// LoadFromFile loads and validates configuration from YAML file (public for testing)
func (cm *ConfigManager) LoadFromFile(filePath string) error {
	return cm.loadFromFile(filePath)
}

// ApplyDefaults applies default values for missing configuration (public for testing)
func (cm *ConfigManager) ApplyDefaults(config *GocaConfig) {
	cm.applyDefaults(config)
}

// SetConfig sets the configuration (public for testing)
func (cm *ConfigManager) SetConfig(config *GocaConfig) {
	cm.config = config
}
